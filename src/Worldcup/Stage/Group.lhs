> module Worldcup.Stage.Group
>     (
>       fixtures
>     , worlds
>     ) where

> import Data.List (tails, sort, sortBy, groupBy, nub)
> import Data.Function (on)
> import Worldcup.Result
> import Worldcup.Team

> results = [ Win, Draw, Loss ]

> type Fixture = (Team, Team)
> type World   = [(Fixture, Result)]


Fixtures
--------

A function "fixtures" generates all matches (non-repeating combinatorial pairs) for a given group of teams; that is, each team has one fixture against each of the other teams. For example, given a list of teams:

    fixtures [ AUS, BEL, COL, DEN ]

this function will return 6 fixtures:

     [ (AUS , BEL), (AUS , COL), (AUS , DEN), (BEL, COL), (BEL, DEN), (COL, DEN) ]

The function utilises Haskell's list comprehension on the tails of the teams list. It is essentially a nested loop, iterating within each team to pair the "head" of each tail with the remaining elements in that tail. 

Any duplicate teams passed will be ignored (this is achieved by simply filtering out the duplicates before running the algorithm. In a case where it is not possible to make any pairs (e.g. the list contains only a single team), an empty list will be returned.

> fixtures :: [Team] -> [Fixture]
> fixtures []     = []
> fixtures [team] = []
> fixtures teams  = [(teamA, teamB) | (teamA:teams) <- tails uniques, teamB <- teams]
>                     where uniques = nub teams


Worlds
------

A function "worlds" generates all possible worlds (a "world" being a collection of fixtures together with their results) from a given group of fixtures.

This is achieved first through the definition of the private function "resultSets". This function, given a list of possible results will produce a list of all possible permutations of these results across a given size. e.g.:

    resultSets 3 [ Win, Loss, Draw ]

will produce a list of sets of results such as (to show a sample, order may practically differ):

    [
        [ Win, Win, Win ],    [ Win, Win, Draw ],   [ Win, Draw, Win ], [ Draw, Win, Win ],
        [ Win, Win, Loss ],   [ Win, Loss, Win ],   [ Loss, Win, Win ], [ Loss, Win, Draw],
        ...
    ]

> resultSets :: Int -> [Result] -> [[Result]]
> resultSets n results = (sequence . replicate n) results

Each result permutation generated by this function will then be `zip`ed onto the provided set of fixtures, to produce a list of (Fixture, Result) tuples. This logic is encapsulated into the "worlds" function:

> worlds :: [Fixture] -> [World]
> worlds [] = [[]]
> worlds fs = map (zip fs) (resultSets (length fs) results)

Given the above-defined "worlds" and "fixtures" functions, it is possible to create a function that translates directly from a list of teams to a list of worlds through function composition:

    teamsToWorlds = worlds . fixtures