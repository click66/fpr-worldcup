> module Worldcup.Stage.Group
>     (
>       fixtures
>     , matchScores
>     , worlds
>     , worldScores
>     ) where

> import Data.List (tails, sort, sortBy, groupBy, nub)
> import Data.Function (on)
> import Worldcup.Result
> import Worldcup.Team

> results = [ Win, Draw, Loss ]

> type Fixture = (Team, Team)
> type World   = [(Fixture, Result)]


Fixtures
--------

A function "fixtures" generates all matches (non-repeating combinatorial pairs) for a given group of teams; that is, each team has one fixture against each of the other teams. For example, given a list of teams:

    fixtures [ AUS, BEL, COL, DEN ]

this function will return 6 fixtures:

     [ (AUS , BEL), (AUS , COL), (AUS , DEN), (BEL, COL), (BEL, DEN), (COL, DEN) ]

The function utilises Haskell's list comprehension on the tails of the teams list. It is essentially a nested loop, iterating within each team to pair the "head" of each tail with the remaining elements in that tail. 

Any duplicate teams passed will be ignored (this is achieved by simply filtering out the duplicates before running the algorithm. In a case where it is not possible to make any pairs (e.g. the list contains only a single team), an empty list will be returned.

> fixtures :: [Team] -> [Fixture]
> fixtures []     = []
> fixtures [team] = []
> fixtures teams  = [(teamA, teamB) | (teamA:teams) <- tails uniques, teamB <- teams]
>                     where uniques = nub teams


Worlds
------

A function "worlds" generates all possible worlds (a "world" being a collection of fixtures together with their results) from a given group of fixtures.

This is achieved first through the definition of the private function "resultSets". This function, given a list of possible results will produce a list of all possible permutations of these results across a given size. e.g.:

    resultSets 3 [ Win, Loss, Draw ]

will produce a list of sets of results such as (to show a sample, order may practically differ):

    [
        [ Win, Win, Win ],    [ Win, Win, Draw ],   [ Win, Draw, Win ], [ Draw, Win, Win ],
        [ Win, Win, Loss ],   [ Win, Loss, Win ],   [ Loss, Win, Win ], [ Loss, Win, Draw],
        ...
    ]

> resultSets :: Int -> [Result] -> [[Result]]
> resultSets n results = (sequence . replicate n) results

Each result permutation generated by this function will then be `zip`ed onto the provided set of fixtures, to produce a list of (Fixture, Result) tuples. This logic is encapsulated into the "worlds" function:

> worlds :: [Fixture] -> [World]
> worlds [] = [[]]
> worlds fs = map (zip fs) (resultSets (length fs) results)

Given the above-defined "worlds" and "fixtures" functions, it is possible to create a function that translates directly from a list of teams to a list of worlds through function composition:

    teamsToWorlds = worlds . fixtures


Match Scores
------------

A function "matchScores" translates a (Fixture, Result) tuple into a list of scores (a score being a tuple of (Team, Int), the Int value being that of the number of scored points):

> type Score = (Team, Int)

> matchScores :: (Fixture, Result) -> [Score]
> matchScores ((teamA, teamB), r)
>     | r == Win  = [(teamA, 3), (teamB, 0)]
>     | r == Loss = [(teamA, 0), (teamB, 3)]
>     | r == Draw = [(teamA, 1), (teamB, 1)]


World Scores
------------

Thus a function "worldScores", given a world, will compute all final scores for all teams in the world. The result is a list of scores, e.g.:

    [ (AUS, 9), (BEL, 6), (COL, 3), (DEN, 0) ]

> worldScores :: World -> [Score]
> worldScores w = map groupTotal groupedScores
>   where
>     individualScores  = concat $ map matchScores w
>     groupedScores     = (groupBy (\s1 s2 -> fst s1 == fst s2) . sort) individualScores
>     groupTotal (x:xs) = foldr (\x y -> (fst x, snd x + snd y)) x xs

This function works in several steps. First, `individualScores` maps the previously defined `matchScores` function over the (Fixture, Result) pairs in the given world, giving a list of lists of pairs of scores. "concat" is then used to flatten this into a list of scores, with duplicated teams.

Secondly, `groupedScores` uses a composed "groupBy" and "sort" to create a list of lists of scores, with each list containing exclusively the scores of a particular team.

Finally, the `groupTotal` function performs a "foldr" to sum all point values in a list of scores, utilising the head as the initial value for the "accumulator". This function is then mapped over the list of lists, producing the final list of non-duplicated scores.

From this, it would be possible to compute a list a of all possible score combinations for all possible worlds in a group, using an expression such as:

    [worldScores world | world <- (worlds . fixtures) [ AUS, BEL, CRO, DEN ]]

